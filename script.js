// Data for emojis categorized with names
const emojiData = {
  activiteiten: [
    { char: '🏃‍♂️', name: 'running man' },
    { char: '🏃‍♀️', name: 'running woman' },
    { char: '🏊‍♂️', name: 'swimming man' },
    { char: '🏊‍♀️', name: 'swimming woman' },
    { char: '🚴‍♂️', name: 'cycling man' },
    { char: '🚴‍♀️', name: 'cycling woman' },
    { char: '🧘‍♂️', name: 'man in lotus position' },
    { char: '🧘‍♀️', name: 'woman in lotus position' },
    { char: '🎨', name: 'artist palette' },
    { char: '🎭', name: 'performing arts' },
    { char: '🎤', name: 'microphone' },
    { char: '🎧', name: 'headphone' },
    { char: '🎼', name: 'musical score' },
    { char: '🎹', name: 'musical keyboard' },
    { char: '🥁', name: 'drum' },
    { char: '🎸', name: 'guitar' },
    { char: '🎻', name: 'violin' },
    { char: '🎲', name: 'game die' },
    { char: '🎯', name: 'direct hit' },
    { char: '🎳', name: 'bowling' },
    { char: '⚽', name: 'soccer ball' },
    { char: '🏀', name: 'basketball' },
    { char: '🏈', name: 'american football' },
    { char: '🎾', name: 'tennis' },
    { char: '🏐', name: 'volleyball' },
    { char: '🏓', name: 'ping pong' },
    { char: '🏸', name: 'badminton' },
  ],
  emoties: [
    { char: '😀', name: 'grinning face' },
    { char: '😁', name: 'beaming face with smiling eyes' },
    { char: '😂', name: 'face with tears of joy' },
    { char: '🤣', name: 'rolling on the floor laughing' },
    { char: '😃', name: 'grinning face with big eyes' },
    { char: '😄', name: 'grinning face with smiling eyes' },
    { char: '😅', name: 'grinning face with sweat' },
    { char: '😆', name: 'grinning squinting face' },
    { char: '😉', name: 'winking face' },
    { char: '😊', name: 'smiling face with smiling eyes' },
    { char: '😎', name: 'smiling face with sunglasses' },
    { char: '😍', name: 'smiling face with heart-eyes' },
    { char: '😘', name: 'face blowing a kiss' },
    { char: '😗', name: 'kissing face' },
    { char: '😙', name: 'kissing face with smiling eyes' },
    { char: '😚', name: 'kissing face with closed eyes' },
    { char: '☺️', name: 'smiling face' },
    { char: '🙂', name: 'slightly smiling face' },
    { char: '🤗', name: 'hugging face' },
    { char: '🤩', name: 'star-struck' },
  ],
  dieren: [
    { char: '🐶', name: 'dog face' },
    { char: '🐱', name: 'cat face' },
    { char: '🐭', name: 'mouse face' },
    { char: '🐹', name: 'hamster face' },
    { char: '🐰', name: 'rabbit face' },
    { char: '🦊', name: 'fox face' },
    { char: '🐻', name: 'bear face' },
    { char: '🐼', name: 'panda face' },
    { char: '🐨', name: 'koala' },
    { char: '🐯', name: 'tiger face' },
    { char: '🦁', name: 'lion face' },
    { char: '🐮', name: 'cow face' },
    { char: '🐷', name: 'pig face' },
    { char: '🐸', name: 'frog face' },
    { char: '🐵', name: 'monkey face' },
    { char: '🙈', name: 'see-no-evil monkey' },
    { char: '🙉', name: 'hear-no-evil monkey' },
    { char: '🙊', name: 'speak-no-evil monkey' },
  ],
  eten: [
    { char: '🍏', name: 'green apple' },
    { char: '🍎', name: 'red apple' },
    { char: '🍐', name: 'pear' },
    { char: '🍊', name: 'tangerine' },
    { char: '🍋', name: 'lemon' },
    { char: '🍌', name: 'banana' },
    { char: '🍉', name: 'watermelon' },
    { char: '🍇', name: 'grapes' },
    { char: '🍓', name: 'strawberry' },
    { char: '🍈', name: 'melon' },
    { char: '🍒', name: 'cherries' },
    { char: '🍑', name: 'peach' },
    { char: '🍍', name: 'pineapple' },
    { char: '🥥', name: 'coconut' },
    { char: '🥝', name: 'kiwi fruit' },
    { char: '🍅', name: 'tomato' },
    { char: '🥑', name: 'avocado' },
    { char: '🍆', name: 'eggplant' },
    { char: '🥦', name: 'broccoli' },
    { char: '🥕', name: 'carrot' },
  ],
  reizen: [
    { char: '✈️', name: 'airplane' },
    { char: '🚗', name: 'car' },
    { char: '🚂', name: 'locomotive' },
    { char: '🚢', name: 'ship' },
    { char: '🛳️', name: 'passenger ship' },
    { char: '🚀', name: 'rocket' },
    { char: '🚁', name: 'helicopter' },
    { char: '🚲', name: 'bicycle' },
    { char: '🛴', name: 'kick scooter' },
    { char: '🛵', name: 'motor scooter' },
    { char: '🏍️', name: 'motorcycle' },
    { char: '🚌', name: 'bus' },
    { char: '🚎', name: 'trolleybus' },
    { char: '🚓', name: 'police car' },
    { char: '🚑', name: 'ambulance' },
    { char: '🚒', name: 'fire engine' },
    { char: '🚚', name: 'delivery truck' },
    { char: '🚜', name: 'tractor' },
  ],
  objecten: [
    { char: '⌚', name: 'watch' },
    { char: '📱', name: 'mobile phone' },
    { char: '💻', name: 'laptop' },
    { char: '🖨️', name: 'printer' },
    { char: '💡', name: 'light bulb' },
    { char: '🔦', name: 'flashlight' },
    { char: '📷', name: 'camera' },
    { char: '📺', name: 'television' },
    { char: '🎥', name: 'movie camera' },
    { char: '🎬', name: 'clapper board' },
    { char: '📽️', name: 'film projector' },
    { char: '☎️', name: 'telephone' },
    { char: '📟', name: 'pager' },
    { char: '📠', name: 'fax machine' },
    { char: '💿', name: 'optical disk' },
    { char: '📼', name: 'videocassette' },
  ],
  symbolen: [
    { char: '❤️', name: 'red heart' },
    { char: '💛', name: 'yellow heart' },
    { char: '💚', name: 'green heart' },
    { char: '💙', name: 'blue heart' },
    { char: '💜', name: 'purple heart' },
    { char: '🖤', name: 'black heart' },
    { char: '💔', name: 'broken heart' },
    { char: '💕', name: 'two hearts' },
    { char: '💞', name: 'revolving hearts' },
    { char: '💓', name: 'beating heart' },
    { char: '💗', name: 'growing heart' },
    { char: '💖', name: 'sparkling heart' },
    { char: '💘', name: 'heart with arrow' },
    { char: '💝', name: 'heart with ribbon' },
    { char: '💟', name: 'heart decoration' },
  ],
  natuur: [
    { char: '🌞', name: 'sun with face' },
    { char: '🌝', name: 'full moon with face' },
    { char: '🌛', name: 'first quarter moon with face' },
    { char: '🌜', name: 'last quarter moon with face' },
    { char: '🌚', name: 'new moon with face' },
    { char: '🌈', name: 'rainbow' },
    { char: '⭐', name: 'star' },
    { char: '🌟', name: 'glowing star' },
    { char: '🌠', name: 'shooting star' },
    { char: '☁️', name: 'cloud' },
    { char: '⛅', name: 'sun behind cloud' },
    { char: '☂️', name: 'umbrella' },
    { char: '❄️', name: 'snowflake' },
    { char: '🔥', name: 'fire' },
    { char: '💧', name: 'droplet' },
    { char: '🌊', name: 'water wave' },
  ],
};

// List of category names
let categories = Object.keys(emojiData);
let currentCategoryIndex = 0;

// Variables for drag-and-drop functionality
let draggedEmoji = null;
let draggedEmojiClone = null;
let currentDroppable = null;

// Variables for the How-To overlay navigation
let currentSlideIndex = 0;

// Error Logging Function
function logError(eventType, message, details = {}) {
  console.error(`Error [${eventType}]: ${message}`, details);
}

// Initialize the application
function init() {
  try {
    // Load the default emoji category
    loadEmojis(categories[currentCategoryIndex]);

    // Update live time every second
    updateLiveTime();
    setInterval(updateLiveTime, 1000);

    // Initialize placeholders
    initializePlaceholders();

    // Initialize event listeners
    addGlobalEventListeners();

    // Check if How-To overlay should be shown
    checkHowToOverlay();
  } catch (error) {
    logError('init', 'Failed to initialize the application.', { error });
  }
}

// Function to initialize placeholders
function initializePlaceholders() {
  document.querySelectorAll('.add-placeholder-button').forEach(button => {
    button.addEventListener('click', handleAddPlaceholder);
  });

  document.querySelectorAll('.emoji-placeholder').forEach(placeholder => {
    makePlaceholderDroppable(placeholder);
  });
}

// Function to handle adding a new placeholder
function handleAddPlaceholder() {
  const sector = this.closest('.sector');
  const placeholdersContainer = sector.querySelector('.placeholders');
  const time = this.previousElementSibling.getAttribute('data-time');
  const currentPlaceholders = placeholdersContainer.querySelectorAll('.placeholder-container').length;

  if (currentPlaceholders < 5) {
    // Create new placeholder
    const newPlaceholderContainer = document.createElement('div');
    newPlaceholderContainer.classList.add('placeholder-container');

    const placeholder = document.createElement('div');
    placeholder.classList.add('emoji-placeholder');
    placeholder.setAttribute('data-time', time);
    makePlaceholderDroppable(placeholder);

    const addButton = document.createElement('button');
    addButton.classList.add('add-placeholder-button');
    addButton.textContent = '+';
    addButton.addEventListener('click', handleAddPlaceholder);

    newPlaceholderContainer.appendChild(placeholder);
    newPlaceholderContainer.appendChild(addButton);
    placeholdersContainer.appendChild(newPlaceholderContainer);
  } else {
    alert('Maximum aantal placeholders bereikt voor deze sectie.');
  }
}

// Function to make placeholders droppable
function makePlaceholderDroppable(placeholder) {
  placeholder.addEventListener('touchstart', handlePlaceholderTouchStart, false);
  placeholder.addEventListener('touchmove', handlePlaceholderTouchMove, false);
  placeholder.addEventListener('touchend', handlePlaceholderTouchEnd, false);

  placeholder.addEventListener('mousedown', handlePlaceholderMouseDown, false);
}

// Handle touch start on placeholder
function handlePlaceholderTouchStart(e) {
  if (this.textContent && !this.hasAttribute('data-empty')) {
    e.preventDefault();
    draggedEmoji = this;
    draggedEmojiClone = this.cloneNode(true);
    draggedEmojiClone.classList.add('dragging-clone');
    document.body.appendChild(draggedEmojiClone);
    const touch = e.touches[0];
    updateDraggedEmojiPosition(touch);
    initAutoScroll();
  }
}

// Handle touch move on placeholder
function handlePlaceholderTouchMove(e) {
  if (!draggedEmojiClone) return;
  e.preventDefault();
  const touch = e.touches[0];
  updateDraggedEmojiPosition(touch);
  autoScroll(touch.clientY);
}

// Handle touch end on placeholder
function handlePlaceholderTouchEnd(e) {
  if (draggedEmojiClone) {
    e.preventDefault();
    draggedEmojiClone.remove();
    draggedEmojiClone = null;
    this.textContent = '';
    this.setAttribute('data-empty', 'true');
    stopAutoScroll();
  }
}

// Similar functions for mouse events
function handlePlaceholderMouseDown(e) {
  if (this.textContent && !this.hasAttribute('data-empty')) {
    e.preventDefault();
    draggedEmoji = this;
    draggedEmojiClone = this.cloneNode(true);
    draggedEmojiClone.classList.add('dragging-clone');
    document.body.appendChild(draggedEmojiClone);
    updateDraggedEmojiPosition(e);
    initAutoScroll();
    document.addEventListener('mousemove', handlePlaceholderMouseMove, false);
    document.addEventListener('mouseup', handlePlaceholderMouseUp, false);
  }
}

function handlePlaceholderMouseMove(e) {
  if (!draggedEmojiClone) return;
  e.preventDefault();
  updateDraggedEmojiPosition(e);
  autoScroll(e.clientY);
}

function handlePlaceholderMouseUp(e) {
  if (draggedEmojiClone) {
    e.preventDefault();
    draggedEmojiClone.remove();
    draggedEmojiClone = null;
    draggedEmoji.textContent = '';
    draggedEmoji.setAttribute('data-empty', 'true');
    stopAutoScroll();
    document.removeEventListener('mousemove', handlePlaceholderMouseMove, false);
    document.removeEventListener('mouseup', handlePlaceholderMouseUp, false);
  }
}

// Function to load emojis
function loadEmojis(category) {
  try {
    const emojiGrid = document.getElementById('emoji-grid');
    emojiGrid.innerHTML = ''; // Clear existing emojis
    const emojis = emojiData[category];

    // Create and append emoji items
    emojis.forEach(emojiObj => {
      const emojiItem = createEmojiItem(emojiObj.char, emojiObj.name);
      emojiGrid.appendChild(emojiItem);
    });

    // Update the category name display
    const categoryNameDisplay = document.getElementById('category-name');
    categoryNameDisplay.textContent = category.charAt(0).toUpperCase() + category.slice(1);
  } catch (error) {
    logError('loadEmojis', 'Failed to load emojis for category.', { category, error });
  }
}

// Function to create an emoji item
function createEmojiItem(emojiChar, emojiName) {
  const emojiItem = document.createElement('div');
  emojiItem.classList.add('emoji-item');
  emojiItem.textContent = emojiChar;
  emojiItem.dataset.name = emojiName.toLowerCase();

  // Make the emoji draggable
  emojiItem.setAttribute('draggable', 'true');

  // Touch event listeners for drag-and-drop
  emojiItem.addEventListener('touchstart', handleDragStart, false);
  emojiItem.addEventListener('touchmove', handleDragMove, false);
  emojiItem.addEventListener('touchend', handleDragEnd, false);

  // Mouse event listeners for desktop
  emojiItem.addEventListener('mousedown', handleMouseDown, false);

  return emojiItem;
}

// Drag-and-Drop Event Handlers for Emojis
function handleDragStart(e) {
  try {
    e.preventDefault();
    e.stopPropagation();
    draggedEmoji = e.target;
    draggedEmojiClone = draggedEmoji.cloneNode(true);
    draggedEmojiClone.classList.add('dragging-clone');
    document.body.appendChild(draggedEmojiClone);

    // Position the clone at the touch point
    const touch = e.touches[0];
    updateDraggedEmojiPosition(touch);

    // Initialize auto-scrolling
    initAutoScroll();
  } catch (error) {
    logError('handleDragStart', 'Failed during drag start.', { error });
  }
}

function handleDragMove(e) {
  try {
    if (!draggedEmojiClone) return;

    e.preventDefault();
    e.stopPropagation();
    const touch = e.touches[0];
    updateDraggedEmojiPosition(touch);

    // Get the element under the touch point
    const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
    if (!elementBelow) return;

    const droppableBelow = elementBelow.closest('.emoji-placeholder');

    if (currentDroppable !== droppableBelow) {
      if (currentDroppable) {
        currentDroppable.classList.remove('highlight');
      }
      currentDroppable = droppableBelow;
      if (currentDroppable) {
        currentDroppable.classList.add('highlight');
      }
    }

    // Auto-scroll when near the edge
    autoScroll(touch.clientY);
  } catch (error) {
    logError('handleDragMove', 'Failed during drag move.', { error });
  }
}

function handleDragEnd(e) {
  try {
    if (!draggedEmojiClone) return;

    e.preventDefault();
    e.stopPropagation();
    draggedEmojiClone.remove();
    draggedEmojiClone = null;

    if (currentDroppable) {
      // Place the emoji in the placeholder
      currentDroppable.textContent = draggedEmoji.textContent;
      currentDroppable.classList.remove('highlight');
      currentDroppable.removeAttribute('data-empty');
    }

    draggedEmoji = null;
    currentDroppable = null;

    // Stop auto-scrolling
    stopAutoScroll();
  } catch (error) {
    logError('handleDragEnd', 'Failed during drag end.', { error });
  }
}

// Mouse Event Handlers for Desktop Support
function handleMouseDown(e) {
  try {
    e.preventDefault();
    e.stopPropagation();
    draggedEmoji = e.target;
    draggedEmojiClone = draggedEmoji.cloneNode(true);
    draggedEmojiClone.classList.add('dragging-clone');
    document.body.appendChild(draggedEmojiClone);

    // Position the clone at the mouse point
    updateDraggedEmojiPosition(e);

    // Initialize auto-scrolling
    initAutoScroll();

    // Mouse move and up handlers
    document.addEventListener('mousemove', handleMouseMove, false);
    document.addEventListener('mouseup', handleMouseUp, false);
  } catch (error) {
    logError('handleMouseDown', 'Failed during mouse down.', { error });
  }
}

function handleMouseMove(e) {
  try {
    if (!draggedEmojiClone) return;

    e.preventDefault();
    e.stopPropagation();
    updateDraggedEmojiPosition(e);

    const elementBelow = document.elementFromPoint(e.clientX, e.clientY);
    if (!elementBelow) return;

    const droppableBelow = elementBelow.closest('.emoji-placeholder');

    if (currentDroppable !== droppableBelow) {
      if (currentDroppable) {
        currentDroppable.classList.remove('highlight');
      }
      currentDroppable = droppableBelow;
      if (currentDroppable) {
        currentDroppable.classList.add('highlight');
      }
    }

    // Auto-scroll when near the edge
    autoScroll(e.clientY);
  } catch (error) {
    logError('handleMouseMove', 'Failed during mouse move.', { error });
  }
}

function handleMouseUp(e) {
  try {
    if (!draggedEmojiClone) return;

    e.preventDefault();
    e.stopPropagation();
    draggedEmojiClone.remove();
    draggedEmojiClone = null;

    if (currentDroppable) {
      // Place the emoji in the placeholder
      currentDroppable.textContent = draggedEmoji.textContent;
      currentDroppable.classList.remove('highlight');
      currentDroppable.removeAttribute('data-empty');
    }

    draggedEmoji = null;
    currentDroppable = null;

    // Stop auto-scrolling
    stopAutoScroll();

    document.removeEventListener('mousemove', handleMouseMove, false);
    document.removeEventListener('mouseup', handleMouseUp, false);
  } catch (error) {
    logError('handleMouseUp', 'Failed during mouse up.', { error });
  }
}

// Update the position of the dragged emoji clone
function updateDraggedEmojiPosition(event) {
  try {
    const x = event.clientX || (event.touches && event.touches[0].clientX);
    const y = event.clientY || (event.touches && event.touches[0].clientY);
    const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

    // Position the clone under the cursor/finger
    draggedEmojiClone.style.left = `${x + scrollLeft}px`;
    draggedEmojiClone.style.top = `${y + scrollTop}px`;
    draggedEmojiClone.style.position = 'absolute';
    draggedEmojiClone.style.zIndex = 1000;
  } catch (error) {
    logError('updateDraggedEmojiPosition', 'Failed to update dragged emoji position.', { error });
  }
}

// Auto-scroll variables
let autoScrollInterval = null;
const scrollThreshold = 50; // Distance from edge in pixels
const scrollSpeed = 10; // Pixels per interval

// Initialize auto-scrolling
function initAutoScroll() {
  if (autoScrollInterval) return;
  autoScrollInterval = setInterval(() => {}, 20); // Placeholder, actual scrolling happens in autoScroll()
}

// Auto-scroll function
function autoScroll(pointerY) {
  const viewportHeight = window.innerHeight;
  const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
  const maxScroll = document.documentElement.scrollHeight - viewportHeight;

  if (pointerY < scrollThreshold && scrollTop > 0) {
    // Scroll up
    window.scrollBy(0, -scrollSpeed);
  } else if (pointerY > viewportHeight - scrollThreshold && scrollTop < maxScroll) {
    // Scroll down
    window.scrollBy(0, scrollSpeed);
  }
}

// Stop auto-scrolling
function stopAutoScroll() {
  clearInterval(autoScrollInterval);
  autoScrollInterval = null;
}

// Event listeners for category navigation
document.getElementById('prev-category').addEventListener('click', () => navigateCategory('prev'));
document.getElementById('next-category').addEventListener('click', () => navigateCategory('next'));

// Function to navigate categories
function navigateCategory(direction) {
  try {
    if (direction === 'prev') {
      currentCategoryIndex = (currentCategoryIndex - 1 + categories.length) % categories.length;
    } else if (direction === 'next') {
      currentCategoryIndex = (currentCategoryIndex + 1) % categories.length;
    }
    const newCategory = categories[currentCategoryIndex];
    loadEmojis(newCategory);
  } catch (error) {
    logError('navigateCategory', 'Failed to navigate categories.', { direction, error });
  }
}

// Emoji search functionality
const emojiSearchInput = document.getElementById('emoji-search-input');
emojiSearchInput.addEventListener('input', function() {
  const searchTerm = this.value.toLowerCase();
  filterEmojis(searchTerm);
});

function filterEmojis(searchTerm) {
  const emojis = document.querySelectorAll('.emoji-item');
  emojis.forEach(emoji => {
    if (emoji.dataset.name.includes(searchTerm)) {
      emoji.style.display = 'flex';
    } else {
      emoji.style.display = 'none';
    }
  });
}

// Huiswerk Button Toggle Functionality
const huiswerkButton = document.querySelector('.huiswerk-button');
huiswerkButton.addEventListener('click', () => {
  try {
    huiswerkButton.classList.toggle('active');

    if (huiswerkButton.classList.contains('active')) {
      // Add thumbs-up animation
      const thumbSpan = document.createElement('span');
      thumbSpan.textContent = '👍';
      thumbSpan.classList.add('thumb-animation');
      huiswerkButton.appendChild(thumbSpan);

      setTimeout(() => {
        thumbSpan.remove();
      }, 2000); // Remove after 2 seconds
    }
  } catch (error) {
    logError('huiswerkButton', 'Failed to toggle Huiswerk button.', { error });
  }
});

// Update live time display
function updateLiveTime() {
  try {
    const liveTimeElement = document.getElementById('live-time');
    const now = new Date();
    liveTimeElement.textContent = now.toLocaleTimeString();
  } catch (error) {
    logError('updateLiveTime', 'Failed to update live time.', { error });
  }
}

// Reset Button Functionality
document.getElementById('reset-button').addEventListener('click', () => {
  try {
    // Clear emojis from placeholders
    const placeholders = document.querySelectorAll('.emoji-placeholder');
    placeholders.forEach(placeholder => {
      placeholder.textContent = '';
      placeholder.setAttribute('data-empty', 'true');
    });

    // Reset Huiswerk button
    huiswerkButton.classList.remove('active');

    // Reset day rating
    ratingButtons.forEach(button => {
      button.classList.remove('selected');
    });
  } catch (error) {
    logError('resetButton', 'Failed to reset planner.', { error });
  }
});

// Day Rating System
const ratingButtons = document.querySelectorAll('.rating-button');
ratingButtons.forEach(button => {
  button.addEventListener('click', () => {
    try {
      ratingButtons.forEach(btn => {
        btn.classList.remove('selected');
      });
      button.classList.add('selected');
    } catch (error) {
      logError('ratingButton', 'Failed to select rating.', { button, error });
    }
  });
});

// Header Logo Flip Animation
window.addEventListener('load', () => {
  try {
    const headerLogo = document.getElementById('header-logo');
    headerLogo.classList.add('flip-animation');
    // Remove the animation class after it completes to prevent looping
    headerLogo.addEventListener('animationend', () => {
      headerLogo.classList.remove('flip-animation');
    });
  } catch (error) {
    logError('headerLogoAnimation', 'Failed to animate header logo.', { error });
  }
});

// How-To Overlay Navigation
const howToOverlay = document.getElementById('how-to-overlay');
const howToSlides = document.querySelectorAll('.how-to-slide');
const howToCloseButton = document.getElementById('how-to-close');

function showSlide(index) {
  howToSlides.forEach((slide, i) => {
    slide.classList.toggle('active', i === index);
  });
}

document.addEventListener('click', function(e) {
  if (e.target.id === 'how-to-next') {
    if (currentSlideIndex < howToSlides.length - 1) {
      currentSlideIndex++;
      showSlide(currentSlideIndex);
    }
  } else if (e.target.id === 'how-to-prev') {
    if (currentSlideIndex > 0) {
      currentSlideIndex--;
      showSlide(currentSlideIndex);
    }
  }
});

howToCloseButton.addEventListener('click', () => {
  howToOverlay.style.display = 'none';
  localStorage.setItem('howToSeen', 'true');
});

// Show How-To overlay only if not seen before
function checkHowToOverlay() {
  if (!localStorage.getItem('howToSeen')) {
    howToOverlay.style.display = 'flex';
  } else {
    howToOverlay.style.display = 'none';
  }
}

// Initialize the application
init();
