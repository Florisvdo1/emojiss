// Data for emojis categorized with names
const emojiData = {
  activiteiten: [
    { char: 'ðŸƒâ€â™‚ï¸', name: 'running man' },
    { char: 'ðŸƒâ€â™€ï¸', name: 'running woman' },
    { char: 'ðŸŠâ€â™‚ï¸', name: 'swimming man' },
    { char: 'ðŸŠâ€â™€ï¸', name: 'swimming woman' },
    { char: 'ðŸš´â€â™‚ï¸', name: 'cycling man' },
    { char: 'ðŸš´â€â™€ï¸', name: 'cycling woman' },
    { char: 'ðŸ§˜â€â™‚ï¸', name: 'man in lotus position' },
    { char: 'ðŸ§˜â€â™€ï¸', name: 'woman in lotus position' },
    { char: 'ðŸŽ¨', name: 'artist palette' },
    { char: 'ðŸŽ­', name: 'performing arts' },
    { char: 'ðŸŽ¤', name: 'microphone' },
    { char: 'ðŸŽ§', name: 'headphone' },
    { char: 'ðŸŽ¼', name: 'musical score' },
    { char: 'ðŸŽ¹', name: 'musical keyboard' },
    { char: 'ðŸ¥', name: 'drum' },
    { char: 'ðŸŽ¸', name: 'guitar' },
    { char: 'ðŸŽ»', name: 'violin' },
    { char: 'ðŸŽ²', name: 'game die' },
    { char: 'ðŸŽ¯', name: 'direct hit' },
    { char: 'ðŸŽ³', name: 'bowling' },
    { char: 'âš½', name: 'soccer ball' },
    { char: 'ðŸ€', name: 'basketball' },
    { char: 'ðŸˆ', name: 'american football' },
    { char: 'ðŸŽ¾', name: 'tennis' },
    { char: 'ðŸ', name: 'volleyball' },
    { char: 'ðŸ“', name: 'ping pong' },
    { char: 'ðŸ¸', name: 'badminton' },
  ],
  emoties: [
    { char: 'ðŸ˜€', name: 'grinning face' },
    { char: 'ðŸ˜', name: 'beaming face with smiling eyes' },
    { char: 'ðŸ˜‚', name: 'face with tears of joy' },
    { char: 'ðŸ¤£', name: 'rolling on the floor laughing' },
    { char: 'ðŸ˜ƒ', name: 'grinning face with big eyes' },
    { char: 'ðŸ˜„', name: 'grinning face with smiling eyes' },
    { char: 'ðŸ˜…', name: 'grinning face with sweat' },
    { char: 'ðŸ˜†', name: 'grinning squinting face' },
    { char: 'ðŸ˜‰', name: 'winking face' },
    { char: 'ðŸ˜Š', name: 'smiling face with smiling eyes' },
    { char: 'ðŸ˜Ž', name: 'smiling face with sunglasses' },
    { char: 'ðŸ˜', name: 'smiling face with heart-eyes' },
    { char: 'ðŸ˜˜', name: 'face blowing a kiss' },
    { char: 'ðŸ˜—', name: 'kissing face' },
    { char: 'ðŸ˜™', name: 'kissing face with smiling eyes' },
    { char: 'ðŸ˜š', name: 'kissing face with closed eyes' },
    { char: 'â˜ºï¸', name: 'smiling face' },
    { char: 'ðŸ™‚', name: 'slightly smiling face' },
    { char: 'ðŸ¤—', name: 'hugging face' },
    { char: 'ðŸ¤©', name: 'star-struck' },
  ],
  dieren: [
    { char: 'ðŸ¶', name: 'dog face' },
    { char: 'ðŸ±', name: 'cat face' },
    { char: 'ðŸ­', name: 'mouse face' },
    { char: 'ðŸ¹', name: 'hamster face' },
    { char: 'ðŸ°', name: 'rabbit face' },
    { char: 'ðŸ¦Š', name: 'fox face' },
    { char: 'ðŸ»', name: 'bear face' },
    { char: 'ðŸ¼', name: 'panda face' },
    { char: 'ðŸ¨', name: 'koala' },
    { char: 'ðŸ¯', name: 'tiger face' },
    { char: 'ðŸ¦', name: 'lion face' },
    { char: 'ðŸ®', name: 'cow face' },
    { char: 'ðŸ·', name: 'pig face' },
    { char: 'ðŸ¸', name: 'frog face' },
    { char: 'ðŸµ', name: 'monkey face' },
    { char: 'ðŸ™ˆ', name: 'see-no-evil monkey' },
    { char: 'ðŸ™‰', name: 'hear-no-evil monkey' },
    { char: 'ðŸ™Š', name: 'speak-no-evil monkey' },
  ],
  eten: [
    { char: 'ðŸ', name: 'green apple' },
    { char: 'ðŸŽ', name: 'red apple' },
    { char: 'ðŸ', name: 'pear' },
    { char: 'ðŸŠ', name: 'tangerine' },
    { char: 'ðŸ‹', name: 'lemon' },
    { char: 'ðŸŒ', name: 'banana' },
    { char: 'ðŸ‰', name: 'watermelon' },
    { char: 'ðŸ‡', name: 'grapes' },
    { char: 'ðŸ“', name: 'strawberry' },
    { char: 'ðŸˆ', name: 'melon' },
    { char: 'ðŸ’', name: 'cherries' },
    { char: 'ðŸ‘', name: 'peach' },
    { char: 'ðŸ', name: 'pineapple' },
    { char: 'ðŸ¥¥', name: 'coconut' },
    { char: 'ðŸ¥', name: 'kiwi fruit' },
    { char: 'ðŸ…', name: 'tomato' },
    { char: 'ðŸ¥‘', name: 'avocado' },
    { char: 'ðŸ†', name: 'eggplant' },
    { char: 'ðŸ¥¦', name: 'broccoli' },
    { char: 'ðŸ¥•', name: 'carrot' },
  ],
  reizen: [
    { char: 'âœˆï¸', name: 'airplane' },
    { char: 'ðŸš—', name: 'car' },
    { char: 'ðŸš‚', name: 'locomotive' },
    { char: 'ðŸš¢', name: 'ship' },
    { char: 'ðŸ›³ï¸', name: 'passenger ship' },
    { char: 'ðŸš€', name: 'rocket' },
    { char: 'ðŸš', name: 'helicopter' },
    { char: 'ðŸš²', name: 'bicycle' },
    { char: 'ðŸ›´', name: 'kick scooter' },
    { char: 'ðŸ›µ', name: 'motor scooter' },
    { char: 'ðŸï¸', name: 'motorcycle' },
    { char: 'ðŸšŒ', name: 'bus' },
    { char: 'ðŸšŽ', name: 'trolleybus' },
    { char: 'ðŸš“', name: 'police car' },
    { char: 'ðŸš‘', name: 'ambulance' },
    { char: 'ðŸš’', name: 'fire engine' },
    { char: 'ðŸšš', name: 'delivery truck' },
    { char: 'ðŸšœ', name: 'tractor' },
  ],
  objecten: [
    { char: 'âŒš', name: 'watch' },
    { char: 'ðŸ“±', name: 'mobile phone' },
    { char: 'ðŸ’»', name: 'laptop' },
    { char: 'ðŸ–¨ï¸', name: 'printer' },
    { char: 'ðŸ’¡', name: 'light bulb' },
    { char: 'ðŸ”¦', name: 'flashlight' },
    { char: 'ðŸ“·', name: 'camera' },
    { char: 'ðŸ“º', name: 'television' },
    { char: 'ðŸŽ¥', name: 'movie camera' },
    { char: 'ðŸŽ¬', name: 'clapper board' },
    { char: 'ðŸ“½ï¸', name: 'film projector' },
    { char: 'â˜Žï¸', name: 'telephone' },
    { char: 'ðŸ“Ÿ', name: 'pager' },
    { char: 'ðŸ“ ', name: 'fax machine' },
    { char: 'ðŸ’¿', name: 'optical disk' },
    { char: 'ðŸ“¼', name: 'videocassette' },
  ],
  symbolen: [
    { char: 'â¤ï¸', name: 'red heart' },
    { char: 'ðŸ’›', name: 'yellow heart' },
    { char: 'ðŸ’š', name: 'green heart' },
    { char: 'ðŸ’™', name: 'blue heart' },
    { char: 'ðŸ’œ', name: 'purple heart' },
    { char: 'ðŸ–¤', name: 'black heart' },
    { char: 'ðŸ’”', name: 'broken heart' },
    { char: 'ðŸ’•', name: 'two hearts' },
    { char: 'ðŸ’ž', name: 'revolving hearts' },
    { char: 'ðŸ’“', name: 'beating heart' },
    { char: 'ðŸ’—', name: 'growing heart' },
    { char: 'ðŸ’–', name: 'sparkling heart' },
    { char: 'ðŸ’˜', name: 'heart with arrow' },
    { char: 'ðŸ’', name: 'heart with ribbon' },
    { char: 'ðŸ’Ÿ', name: 'heart decoration' },
  ],
  natuur: [
    { char: 'ðŸŒž', name: 'sun with face' },
    { char: 'ðŸŒ', name: 'full moon with face' },
    { char: 'ðŸŒ›', name: 'first quarter moon with face' },
    { char: 'ðŸŒœ', name: 'last quarter moon with face' },
    { char: 'ðŸŒš', name: 'new moon with face' },
    { char: 'ðŸŒˆ', name: 'rainbow' },
    { char: 'â­', name: 'star' },
    { char: 'ðŸŒŸ', name: 'glowing star' },
    { char: 'ðŸŒ ', name: 'shooting star' },
    { char: 'â˜ï¸', name: 'cloud' },
    { char: 'â›…', name: 'sun behind cloud' },
    { char: 'â˜‚ï¸', name: 'umbrella' },
    { char: 'â„ï¸', name: 'snowflake' },
    { char: 'ðŸ”¥', name: 'fire' },
    { char: 'ðŸ’§', name: 'droplet' },
    { char: 'ðŸŒŠ', name: 'water wave' },
  ],
};

// List of category names
let categories = Object.keys(emojiData);
let currentCategoryIndex = 0;

// Variables for drag-and-drop functionality
let draggedEmoji = null;
let draggedEmojiClone = null;
let currentDroppable = null;

// Variables for the How-To overlay navigation
let currentSlideIndex = 0;

// Error Logging Function
function logError(eventType, message, details = {}) {
  console.error(`Error [${eventType}]: ${message}`, details);
}

// Initialize the application
function init() {
  try {
    // Load the default emoji category
    loadEmojis(categories[currentCategoryIndex]);

    // Update live time every second
    updateLiveTime();
    setInterval(updateLiveTime, 1000);

    // Initialize placeholders
    initializePlaceholders();

    // Initialize event listeners
    addGlobalEventListeners();

    // Check if How-To overlay should be shown
    checkHowToOverlay();
  } catch (error) {
    logError('init', 'Failed to initialize the application.', { error });
  }
}

// Function to initialize placeholders
function initializePlaceholders() {
  document.querySelectorAll('.add-placeholder-button').forEach(button => {
    button.addEventListener('click', handleAddPlaceholder);
  });

  document.querySelectorAll('.emoji-placeholder').forEach(placeholder => {
    makePlaceholderDroppable(placeholder);
  });
}

// Function to handle adding a new placeholder
function handleAddPlaceholder() {
  const sector = this.closest('.sector');
  const placeholdersContainer = sector.querySelector('.placeholders');
  const time = this.previousElementSibling.getAttribute('data-time');
  const currentPlaceholders = placeholdersContainer.querySelectorAll('.placeholder-container').length;

  if (currentPlaceholders < 5) {
    // Create new placeholder
    const newPlaceholderContainer = document.createElement('div');
    newPlaceholderContainer.classList.add('placeholder-container');

    const placeholder = document.createElement('div');
    placeholder.classList.add('emoji-placeholder');
    placeholder.setAttribute('data-time', time);
    makePlaceholderDroppable(placeholder);

    const addButton = document.createElement('button');
    addButton.classList.add('add-placeholder-button');
    addButton.textContent = '+';
    addButton.addEventListener('click', handleAddPlaceholder);

    newPlaceholderContainer.appendChild(placeholder);
    newPlaceholderContainer.appendChild(addButton);
    placeholdersContainer.appendChild(newPlaceholderContainer);
  } else {
    alert('Maximum aantal placeholders bereikt voor deze sectie.');
  }
}

// Function to make placeholders droppable
function makePlaceholderDroppable(placeholder) {
  placeholder.addEventListener('touchstart', handlePlaceholderTouchStart, false);
  placeholder.addEventListener('touchmove', handlePlaceholderTouchMove, false);
  placeholder.addEventListener('touchend', handlePlaceholderTouchEnd, false);

  placeholder.addEventListener('mousedown', handlePlaceholderMouseDown, false);
}

// Handle touch start on placeholder
function handlePlaceholderTouchStart(e) {
  if (this.textContent && !this.hasAttribute('data-empty')) {
    e.preventDefault();
    draggedEmoji = this;
    draggedEmojiClone = this.cloneNode(true);
    draggedEmojiClone.classList.add('dragging-clone');
    document.body.appendChild(draggedEmojiClone);
    const touch = e.touches[0];
    updateDraggedEmojiPosition(touch);
    initAutoScroll();
  }
}

// Handle touch move on placeholder
function handlePlaceholderTouchMove(e) {
  if (!draggedEmojiClone) return;
  e.preventDefault();
  const touch = e.touches[0];
  updateDraggedEmojiPosition(touch);
  autoScroll(touch.clientY);
}

// Handle touch end on placeholder
function handlePlaceholderTouchEnd(e) {
  if (draggedEmojiClone) {
    e.preventDefault();
    draggedEmojiClone.remove();
    draggedEmojiClone = null;
    this.textContent = '';
    this.setAttribute('data-empty', 'true');
    stopAutoScroll();
  }
}

// Similar functions for mouse events
function handlePlaceholderMouseDown(e) {
  if (this.textContent && !this.hasAttribute('data-empty')) {
    e.preventDefault();
    draggedEmoji = this;
    draggedEmojiClone = this.cloneNode(true);
    draggedEmojiClone.classList.add('dragging-clone');
    document.body.appendChild(draggedEmojiClone);
    updateDraggedEmojiPosition(e);
    initAutoScroll();
    document.addEventListener('mousemove', handlePlaceholderMouseMove, false);
    document.addEventListener('mouseup', handlePlaceholderMouseUp, false);
  }
}

function handlePlaceholderMouseMove(e) {
  if (!draggedEmojiClone) return;
  e.preventDefault();
  updateDraggedEmojiPosition(e);
  autoScroll(e.clientY);
}

function handlePlaceholderMouseUp(e) {
  if (draggedEmojiClone) {
    e.preventDefault();
    draggedEmojiClone.remove();
    draggedEmojiClone = null;
    draggedEmoji.textContent = '';
    draggedEmoji.setAttribute('data-empty', 'true');
    stopAutoScroll();
    document.removeEventListener('mousemove', handlePlaceholderMouseMove, false);
    document.removeEventListener('mouseup', handlePlaceholderMouseUp, false);
  }
}

// Function to load emojis
function loadEmojis(category) {
  try {
    const emojiGrid = document.getElementById('emoji-grid');
    emojiGrid.innerHTML = ''; // Clear existing emojis
    const emojis = emojiData[category];

    // Create and append emoji items
    emojis.forEach(emojiObj => {
      const emojiItem = createEmojiItem(emojiObj.char, emojiObj.name);
      emojiGrid.appendChild(emojiItem);
    });

    // Update the category name display
    const categoryNameDisplay = document.getElementById('category-name');
    categoryNameDisplay.textContent = category.charAt(0).toUpperCase() + category.slice(1);
  } catch (error) {
    logError('loadEmojis', 'Failed to load emojis for category.', { category, error });
  }
}

// Function to create an emoji item
function createEmojiItem(emojiChar, emojiName) {
  const emojiItem = document.createElement('div');
  emojiItem.classList.add('emoji-item');
  emojiItem.textContent = emojiChar;
  emojiItem.dataset.name = emojiName.toLowerCase();

  // Make the emoji draggable
  emojiItem.setAttribute('draggable', 'true');

  // Touch event listeners for drag-and-drop
  emojiItem.addEventListener('touchstart', handleDragStart, false);
  emojiItem.addEventListener('touchmove', handleDragMove, false);
  emojiItem.addEventListener('touchend', handleDragEnd, false);

  // Mouse event listeners for desktop
  emojiItem.addEventListener('mousedown', handleMouseDown, false);

  return emojiItem;
}

// Drag-and-Drop Event Handlers for Emojis
function handleDragStart(e) {
  try {
    e.preventDefault();
    e.stopPropagation();
    draggedEmoji = e.target;
    draggedEmojiClone = draggedEmoji.cloneNode(true);
    draggedEmojiClone.classList.add('dragging-clone');
    document.body.appendChild(draggedEmojiClone);

    // Position the clone at the touch point
    const touch = e.touches[0];
    updateDraggedEmojiPosition(touch);

    // Initialize auto-scrolling
    initAutoScroll();
  } catch (error) {
    logError('handleDragStart', 'Failed during drag start.', { error });
  }
}

function handleDragMove(e) {
  try {
    if (!draggedEmojiClone) return;

    e.preventDefault();
    e.stopPropagation();
    const touch = e.touches[0];
    updateDraggedEmojiPosition(touch);

    // Get the element under the touch point
    const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
    if (!elementBelow) return;

    const droppableBelow = elementBelow.closest('.emoji-placeholder');

    if (currentDroppable !== droppableBelow) {
      if (currentDroppable) {
        currentDroppable.classList.remove('highlight');
      }
      currentDroppable = droppableBelow;
      if (currentDroppable) {
        currentDroppable.classList.add('highlight');
      }
    }

    // Auto-scroll when near the edge
    autoScroll(touch.clientY);
  } catch (error) {
    logError('handleDragMove', 'Failed during drag move.', { error });
  }
}

function handleDragEnd(e) {
  try {
    if (!draggedEmojiClone) return;

    e.preventDefault();
    e.stopPropagation();
    draggedEmojiClone.remove();
    draggedEmojiClone = null;

    if (currentDroppable) {
      // Place the emoji in the placeholder
      currentDroppable.textContent = draggedEmoji.textContent;
      currentDroppable.classList.remove('highlight');
      currentDroppable.removeAttribute('data-empty');
    }

    draggedEmoji = null;
    currentDroppable = null;

    // Stop auto-scrolling
    stopAutoScroll();
  } catch (error) {
    logError('handleDragEnd', 'Failed during drag end.', { error });
  }
}

// Mouse Event Handlers for Desktop Support
function handleMouseDown(e) {
  try {
    e.preventDefault();
    e.stopPropagation();
    draggedEmoji = e.target;
    draggedEmojiClone = draggedEmoji.cloneNode(true);
    draggedEmojiClone.classList.add('dragging-clone');
    document.body.appendChild(draggedEmojiClone);

    // Position the clone at the mouse point
    updateDraggedEmojiPosition(e);

    // Initialize auto-scrolling
    initAutoScroll();

    // Mouse move and up handlers
    document.addEventListener('mousemove', handleMouseMove, false);
    document.addEventListener('mouseup', handleMouseUp, false);
  } catch (error) {
    logError('handleMouseDown', 'Failed during mouse down.', { error });
  }
}

function handleMouseMove(e) {
  try {
    if (!draggedEmojiClone) return;

    e.preventDefault();
    e.stopPropagation();
    updateDraggedEmojiPosition(e);

    const elementBelow = document.elementFromPoint(e.clientX, e.clientY);
    if (!elementBelow) return;

    const droppableBelow = elementBelow.closest('.emoji-placeholder');

    if (currentDroppable !== droppableBelow) {
      if (currentDroppable) {
        currentDroppable.classList.remove('highlight');
      }
      currentDroppable = droppableBelow;
      if (currentDroppable) {
        currentDroppable.classList.add('highlight');
      }
    }

    // Auto-scroll when near the edge
    autoScroll(e.clientY);
  } catch (error) {
    logError('handleMouseMove', 'Failed during mouse move.', { error });
  }
}

function handleMouseUp(e) {
  try {
    if (!draggedEmojiClone) return;

    e.preventDefault();
    e.stopPropagation();
    draggedEmojiClone.remove();
    draggedEmojiClone = null;

    if (currentDroppable) {
      // Place the emoji in the placeholder
      currentDroppable.textContent = draggedEmoji.textContent;
      currentDroppable.classList.remove('highlight');
      currentDroppable.removeAttribute('data-empty');
    }

    draggedEmoji = null;
    currentDroppable = null;

    // Stop auto-scrolling
    stopAutoScroll();

    document.removeEventListener('mousemove', handleMouseMove, false);
    document.removeEventListener('mouseup', handleMouseUp, false);
  } catch (error) {
    logError('handleMouseUp', 'Failed during mouse up.', { error });
  }
}

// Update the position of the dragged emoji clone
function updateDraggedEmojiPosition(event) {
  try {
    const x = event.clientX || (event.touches && event.touches[0].clientX);
    const y = event.clientY || (event.touches && event.touches[0].clientY);
    const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

    // Position the clone under the cursor/finger
    draggedEmojiClone.style.left = `${x + scrollLeft}px`;
    draggedEmojiClone.style.top = `${y + scrollTop}px`;
    draggedEmojiClone.style.position = 'absolute';
    draggedEmojiClone.style.zIndex = 1000;
  } catch (error) {
    logError('updateDraggedEmojiPosition', 'Failed to update dragged emoji position.', { error });
  }
}

// Auto-scroll variables
let autoScrollInterval = null;
const scrollThreshold = 50; // Distance from edge in pixels
const scrollSpeed = 10; // Pixels per interval

// Initialize auto-scrolling
function initAutoScroll() {
  if (autoScrollInterval) return;
  autoScrollInterval = setInterval(() => {}, 20); // Placeholder, actual scrolling happens in autoScroll()
}

// Auto-scroll function
function autoScroll(pointerY) {
  const viewportHeight = window.innerHeight;
  const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
  const maxScroll = document.documentElement.scrollHeight - viewportHeight;

  if (pointerY < scrollThreshold && scrollTop > 0) {
    // Scroll up
    window.scrollBy(0, -scrollSpeed);
  } else if (pointerY > viewportHeight - scrollThreshold && scrollTop < maxScroll) {
    // Scroll down
    window.scrollBy(0, scrollSpeed);
  }
}

// Stop auto-scrolling
function stopAutoScroll() {
  clearInterval(autoScrollInterval);
  autoScrollInterval = null;
}

// Event listeners for category navigation
document.getElementById('prev-category').addEventListener('click', () => navigateCategory('prev'));
document.getElementById('next-category').addEventListener('click', () => navigateCategory('next'));

// Function to navigate categories
function navigateCategory(direction) {
  try {
    if (direction === 'prev') {
      currentCategoryIndex = (currentCategoryIndex - 1 + categories.length) % categories.length;
    } else if (direction === 'next') {
      currentCategoryIndex = (currentCategoryIndex + 1) % categories.length;
    }
    const newCategory = categories[currentCategoryIndex];
    loadEmojis(newCategory);
  } catch (error) {
    logError('navigateCategory', 'Failed to navigate categories.', { direction, error });
  }
}

// Emoji search functionality
const emojiSearchInput = document.getElementById('emoji-search-input');
emojiSearchInput.addEventListener('input', function() {
  const searchTerm = this.value.toLowerCase();
  filterEmojis(searchTerm);
});

function filterEmojis(searchTerm) {
  const emojis = document.querySelectorAll('.emoji-item');
  emojis.forEach(emoji => {
    if (emoji.dataset.name.includes(searchTerm)) {
      emoji.style.display = 'flex';
    } else {
      emoji.style.display = 'none';
    }
  });
}

// Huiswerk Button Toggle Functionality
const huiswerkButton = document.querySelector('.huiswerk-button');
huiswerkButton.addEventListener('click', () => {
  try {
    huiswerkButton.classList.toggle('active');

    if (huiswerkButton.classList.contains('active')) {
      // Add thumbs-up animation
      const thumbSpan = document.createElement('span');
      thumbSpan.textContent = 'ðŸ‘';
      thumbSpan.classList.add('thumb-animation');
      huiswerkButton.appendChild(thumbSpan);

      setTimeout(() => {
        thumbSpan.remove();
      }, 2000); // Remove after 2 seconds
    }
  } catch (error) {
    logError('huiswerkButton', 'Failed to toggle Huiswerk button.', { error });
  }
});

// Update live time display
function updateLiveTime() {
  try {
    const liveTimeElement = document.getElementById('live-time');
    const now = new Date();
    liveTimeElement.textContent = now.toLocaleTimeString();
  } catch (error) {
    logError('updateLiveTime', 'Failed to update live time.', { error });
  }
}

// Reset Button Functionality
document.getElementById('reset-button').addEventListener('click', () => {
  try {
    // Clear emojis from placeholders
    const placeholders = document.querySelectorAll('.emoji-placeholder');
    placeholders.forEach(placeholder => {
      placeholder.textContent = '';
      placeholder.setAttribute('data-empty', 'true');
    });

    // Reset Huiswerk button
    huiswerkButton.classList.remove('active');

    // Reset day rating
    ratingButtons.forEach(button => {
      button.classList.remove('selected');
    });
  } catch (error) {
    logError('resetButton', 'Failed to reset planner.', { error });
  }
});

// Day Rating System
const ratingButtons = document.querySelectorAll('.rating-button');
ratingButtons.forEach(button => {
  button.addEventListener('click', () => {
    try {
      ratingButtons.forEach(btn => {
        btn.classList.remove('selected');
      });
      button.classList.add('selected');
    } catch (error) {
      logError('ratingButton', 'Failed to select rating.', { button, error });
    }
  });
});

// Header Logo Flip Animation
window.addEventListener('load', () => {
  try {
    const headerLogo = document.getElementById('header-logo');
    headerLogo.classList.add('flip-animation');
    // Remove the animation class after it completes to prevent looping
    headerLogo.addEventListener('animationend', () => {
      headerLogo.classList.remove('flip-animation');
    });
  } catch (error) {
    logError('headerLogoAnimation', 'Failed to animate header logo.', { error });
  }
});

// How-To Overlay Navigation
const howToOverlay = document.getElementById('how-to-overlay');
const howToSlides = document.querySelectorAll('.how-to-slide');
const howToCloseButton = document.getElementById('how-to-close');

function showSlide(index) {
  howToSlides.forEach((slide, i) => {
    slide.classList.toggle('active', i === index);
  });
}

document.addEventListener('click', function(e) {
  if (e.target.id === 'how-to-next') {
    if (currentSlideIndex < howToSlides.length - 1) {
      currentSlideIndex++;
      showSlide(currentSlideIndex);
    }
  } else if (e.target.id === 'how-to-prev') {
    if (currentSlideIndex > 0) {
      currentSlideIndex--;
      showSlide(currentSlideIndex);
    }
  }
});

howToCloseButton.addEventListener('click', () => {
  howToOverlay.style.display = 'none';
  localStorage.setItem('howToSeen', 'true');
});

// Show How-To overlay only if not seen before
function checkHowToOverlay() {
  if (!localStorage.getItem('howToSeen')) {
    howToOverlay.style.display = 'flex';
  } else {
    howToOverlay.style.display = 'none';
  }
}

// Initialize the application
init();
